# 单例模式

---

- [说明](#说明)
- [经典懒汉单例模式](#经典懒汉单例模式)
- [枚举方式的单例模式](#枚举方式的单例模式)

---

## 说明

单例模式的**意图**是控制类只能够创建**一个实例**，同时向客户程序提供一个访问它的全局访问点！

`Java`中的典型实现
1. `java.lang.Runtime#getRuntime`
2. `java.awt.Desktop#getDesktop`

单例注意事项
1. 不要实现`Cloneable`接口或者**继承**相关子类
2. 严防**序列化**

## 经典懒汉单例模式

```Java
class Singleton {
	private static Singleton singleton;
	private Singleton() {}
	public static Singleton getInstance() {
		if(singleton == null) {
			singleton = new Singleton();
		}
		return singleton;
	}
}
```

经典懒汉单例在**多线程**下很成问题！当多个线程几乎同时调用`getInstance`，静态成员`singleton`可能还没有被实例化，因此它可能被**不同线程创建多次**！多线程的**无序**造成问题，我们可以通过`synchronized`关键字限制线程**有序**访问`getInstance`，但是又会造成**性能**问题！实际上我们只需要在**构造第一个也是唯一一个单例时**进行同步，因此有了`Double Check`方法！

```Java
class Singleton {
	// volatile确保多线程访问时，每个线程从共享内存读singleton值，修改singleton也必须将新值回写到共享内存
	private static volatile Singleton singleton = null;
	private Singleton() {}

	// 如果没有外层if，则每次都要synchronized，效率低
	// 如果没有内层if，仍然可能实例化多个
	public static Singleton getInstance() {
		if(singleton == null) {
			synchronized(Singleton.class) {
				if(synchronized == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```

## 枚举方式的单例模式

如果需要一个**进程内**的单例特征对象，建议优先选择**枚举**方式！

枚举单例的局限性
1. 枚举不能定义**类型参数**，即枚举不能是**泛型**
2. 枚举的**构造过程**是线程安全，**不代表**它的**成员方法**、**类方法**是线程安全

