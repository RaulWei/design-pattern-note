# 单例模式

---

- [说明](#说明)
- [经典懒汉单例模式](#经典懒汉单例模式)

---

## 说明

单例模式的**意图**是控制类只能够创建**一个实例**，同时向客户程序提供一个访问它的全局访问点！

`Java`中的典型实现
1. `java.lang.Runtime#getRuntime`
2. `java.awt.Desktop#getDesktop`

## 经典懒汉单例模式

```Java
class Singleton {
	private static Singleton singleton;
	private Singleton() {}
	public static Singleton getInstance() {
		if(singleton == null) {
			singleton = new Singleton();
		}
		return singleton;
	}
}
```

经典懒汉单例在**多线程**下很成问题！当多个线程几乎同时调用`getInstance`，静态成员`singleton`可能还没有被实例化，因此它可能被**不同线程创建多次**！多线程的**无序**造成问题，我们可以通过`synchronized`关键字限制线程**有序**访问`getInstance`，但是又会造成**性能**问题！实际上我们只需要在**构造第一个也是唯一一个**单例时进行同步，因此有了`Double Check`方法！

```Java
class Singleton {
	// volatile确保多线程访问时，每个线程从共享内存读singleton值，修改singleton也必须将新值回写到共享内存
	private static volatile Singleton singleton = null;
	private Singleton() {}
	
	// 如果没有外层if，则每次都要synchronized，效率低
	// 如果没有内层if，仍然可能实例化多个
	public static Singleton getInstance() {
		if(singleton == null) {
			synchronized(Singleton.class) {
				if(synchronized == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
```